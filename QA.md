
# 1.服务器sleep, 客户端一直发送消息, 会发生什么

1. 阻塞TCP
    - 双方内核的套接字缓冲区很快被填满， 客户端进程进入 睡眠
2. 非阻塞TCP
    - 双方内核的套接字缓冲区很快被填满， 客户端后续 write 返回错误
3. UDP
    - UDP套接字没有真正的发送缓冲区
    - 对于一个阻塞的UDP套接字（默认设置），write函数调用将不会因为与TCP套接字一样的原因而阻塞，不过有可能会因为其他原因而阻塞。 


# 粘包和拆包 

- UDP
    - UDP协议的保护消息边界使得每一个消息都是独立的
    - UDP不存在粘包问题，是由于UDP发送的时候，没有经过Negal算法优化，不会将多个小包合并一次发送出去。
        - 另外，在UDP协议的接收端，采用了链式结构来记录每一个到达的UDP包，这样接收端应用程序一次recv只能从socket接收缓冲区中读出一个数据包。
        - 也就是说，发送端send了几次，接收端必须recv几次（无论recv时指定了多大的缓冲区）。
    - UDP最大载荷为1472，因此最好能 每次传输接近这个数的数据量


- TCP
    - TCP流传输,把数据当作一串数据流,他不认为数据是一个一个的消息. 
    - 如果发送的网络数据包太小，那么他本身会启用Nagle算法（可配置是否启用）对较小的数据包进行合并（基于此，TCP的网络延迟要UDP的高些）然后再发送（超时或者包大小足够）
    - 对于数据传输频繁的程序来讲，使用TCP可能会容易粘包。
    - 当然，对接收端的程序来讲，如果机器负荷很重，也会在接收缓冲里粘包。这样，就需要接收端额外拆包，增加了工作量。

# 分包

- 分包产生的原因就简单的多：可能是IP分片传输导致的，也可能是传输过程中丢失部分包导致出现的半包，还有可能就是一个包可能被分成了两次传输，在取数据的时候，先取到了一部分（还可能与接收的缓冲区大小有关系），总之就是一个数据包被分成了多次接收。

# 粘包与分包解决方法

1. 采用分隔符
2. 在数据包中添加长度
    - 有个小问题就是如果客户端第一个数据包数据长度封装的有错误，那么很可能就会导致后面接收到的所有数据包都解析出错
    - 对数据长度做校验 ?



# 网络设备工作在哪层？

- 只知道MAC不知道IP的算第2层，例如普通交换机
- 只知道IP不知道port（也就不管TCP还是UDP）的算第3层，例如普通路由器
- 知道IP还知道port的算第4层，例如 NAT


